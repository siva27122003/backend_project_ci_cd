// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	CreateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*UserResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) CreateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*UserResponse, error) {
	out := new(UserResponse)
	err := c.cc.Invoke(ctx, "/cropconnect.UserService/CreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility
type UserServiceServer interface {
	CreateUser(context.Context, *User) (*UserResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserServiceServer struct {
}

func (UnimplementedUserServiceServer) CreateUser(context.Context, *User) (*UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.UserService/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cropconnect.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _UserService_CreateUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cropconnect.proto",
}

// FarmerServiceClient is the client API for FarmerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FarmerServiceClient interface {
	CreateFarmer(ctx context.Context, in *Farmer, opts ...grpc.CallOption) (*FarmerResponse, error)
	UpdateFarmer(ctx context.Context, in *UpdateFarmerRequest, opts ...grpc.CallOption) (*FarmerResponse, error)
	GetFarmerByID(ctx context.Context, in *FarmerRequest, opts ...grpc.CallOption) (*FarmerResponse, error)
	DeleteFarmer(ctx context.Context, in *FarmerRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
}

type farmerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFarmerServiceClient(cc grpc.ClientConnInterface) FarmerServiceClient {
	return &farmerServiceClient{cc}
}

func (c *farmerServiceClient) CreateFarmer(ctx context.Context, in *Farmer, opts ...grpc.CallOption) (*FarmerResponse, error) {
	out := new(FarmerResponse)
	err := c.cc.Invoke(ctx, "/cropconnect.FarmerService/CreateFarmer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *farmerServiceClient) UpdateFarmer(ctx context.Context, in *UpdateFarmerRequest, opts ...grpc.CallOption) (*FarmerResponse, error) {
	out := new(FarmerResponse)
	err := c.cc.Invoke(ctx, "/cropconnect.FarmerService/UpdateFarmer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *farmerServiceClient) GetFarmerByID(ctx context.Context, in *FarmerRequest, opts ...grpc.CallOption) (*FarmerResponse, error) {
	out := new(FarmerResponse)
	err := c.cc.Invoke(ctx, "/cropconnect.FarmerService/GetFarmerByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *farmerServiceClient) DeleteFarmer(ctx context.Context, in *FarmerRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, "/cropconnect.FarmerService/DeleteFarmer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FarmerServiceServer is the server API for FarmerService service.
// All implementations must embed UnimplementedFarmerServiceServer
// for forward compatibility
type FarmerServiceServer interface {
	CreateFarmer(context.Context, *Farmer) (*FarmerResponse, error)
	UpdateFarmer(context.Context, *UpdateFarmerRequest) (*FarmerResponse, error)
	GetFarmerByID(context.Context, *FarmerRequest) (*FarmerResponse, error)
	DeleteFarmer(context.Context, *FarmerRequest) (*DeleteResponse, error)
	mustEmbedUnimplementedFarmerServiceServer()
}

// UnimplementedFarmerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedFarmerServiceServer struct {
}

func (UnimplementedFarmerServiceServer) CreateFarmer(context.Context, *Farmer) (*FarmerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateFarmer not implemented")
}
func (UnimplementedFarmerServiceServer) UpdateFarmer(context.Context, *UpdateFarmerRequest) (*FarmerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFarmer not implemented")
}
func (UnimplementedFarmerServiceServer) GetFarmerByID(context.Context, *FarmerRequest) (*FarmerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFarmerByID not implemented")
}
func (UnimplementedFarmerServiceServer) DeleteFarmer(context.Context, *FarmerRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFarmer not implemented")
}
func (UnimplementedFarmerServiceServer) mustEmbedUnimplementedFarmerServiceServer() {}

// UnsafeFarmerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FarmerServiceServer will
// result in compilation errors.
type UnsafeFarmerServiceServer interface {
	mustEmbedUnimplementedFarmerServiceServer()
}

func RegisterFarmerServiceServer(s grpc.ServiceRegistrar, srv FarmerServiceServer) {
	s.RegisterService(&FarmerService_ServiceDesc, srv)
}

func _FarmerService_CreateFarmer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Farmer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FarmerServiceServer).CreateFarmer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.FarmerService/CreateFarmer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FarmerServiceServer).CreateFarmer(ctx, req.(*Farmer))
	}
	return interceptor(ctx, in, info, handler)
}

func _FarmerService_UpdateFarmer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFarmerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FarmerServiceServer).UpdateFarmer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.FarmerService/UpdateFarmer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FarmerServiceServer).UpdateFarmer(ctx, req.(*UpdateFarmerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FarmerService_GetFarmerByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FarmerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FarmerServiceServer).GetFarmerByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.FarmerService/GetFarmerByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FarmerServiceServer).GetFarmerByID(ctx, req.(*FarmerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FarmerService_DeleteFarmer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FarmerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FarmerServiceServer).DeleteFarmer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.FarmerService/DeleteFarmer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FarmerServiceServer).DeleteFarmer(ctx, req.(*FarmerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FarmerService_ServiceDesc is the grpc.ServiceDesc for FarmerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FarmerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cropconnect.FarmerService",
	HandlerType: (*FarmerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateFarmer",
			Handler:    _FarmerService_CreateFarmer_Handler,
		},
		{
			MethodName: "UpdateFarmer",
			Handler:    _FarmerService_UpdateFarmer_Handler,
		},
		{
			MethodName: "GetFarmerByID",
			Handler:    _FarmerService_GetFarmerByID_Handler,
		},
		{
			MethodName: "DeleteFarmer",
			Handler:    _FarmerService_DeleteFarmer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cropconnect.proto",
}

// CategoryServiceClient is the client API for CategoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CategoryServiceClient interface {
	CreateCategory(ctx context.Context, in *Category, opts ...grpc.CallOption) (*CategoryResponse, error)
	GetCategories(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CategoryList, error)
	DeleteCategory(ctx context.Context, in *CategoryRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
}

type categoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCategoryServiceClient(cc grpc.ClientConnInterface) CategoryServiceClient {
	return &categoryServiceClient{cc}
}

func (c *categoryServiceClient) CreateCategory(ctx context.Context, in *Category, opts ...grpc.CallOption) (*CategoryResponse, error) {
	out := new(CategoryResponse)
	err := c.cc.Invoke(ctx, "/cropconnect.CategoryService/CreateCategory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) GetCategories(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CategoryList, error) {
	out := new(CategoryList)
	err := c.cc.Invoke(ctx, "/cropconnect.CategoryService/GetCategories", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) DeleteCategory(ctx context.Context, in *CategoryRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, "/cropconnect.CategoryService/DeleteCategory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CategoryServiceServer is the server API for CategoryService service.
// All implementations must embed UnimplementedCategoryServiceServer
// for forward compatibility
type CategoryServiceServer interface {
	CreateCategory(context.Context, *Category) (*CategoryResponse, error)
	GetCategories(context.Context, *Empty) (*CategoryList, error)
	DeleteCategory(context.Context, *CategoryRequest) (*DeleteResponse, error)
	mustEmbedUnimplementedCategoryServiceServer()
}

// UnimplementedCategoryServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCategoryServiceServer struct {
}

func (UnimplementedCategoryServiceServer) CreateCategory(context.Context, *Category) (*CategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCategory not implemented")
}
func (UnimplementedCategoryServiceServer) GetCategories(context.Context, *Empty) (*CategoryList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCategories not implemented")
}
func (UnimplementedCategoryServiceServer) DeleteCategory(context.Context, *CategoryRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCategory not implemented")
}
func (UnimplementedCategoryServiceServer) mustEmbedUnimplementedCategoryServiceServer() {}

// UnsafeCategoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CategoryServiceServer will
// result in compilation errors.
type UnsafeCategoryServiceServer interface {
	mustEmbedUnimplementedCategoryServiceServer()
}

func RegisterCategoryServiceServer(s grpc.ServiceRegistrar, srv CategoryServiceServer) {
	s.RegisterService(&CategoryService_ServiceDesc, srv)
}

func _CategoryService_CreateCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Category)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).CreateCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.CategoryService/CreateCategory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).CreateCategory(ctx, req.(*Category))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_GetCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetCategories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.CategoryService/GetCategories",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetCategories(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_DeleteCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).DeleteCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.CategoryService/DeleteCategory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).DeleteCategory(ctx, req.(*CategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CategoryService_ServiceDesc is the grpc.ServiceDesc for CategoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CategoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cropconnect.CategoryService",
	HandlerType: (*CategoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCategory",
			Handler:    _CategoryService_CreateCategory_Handler,
		},
		{
			MethodName: "GetCategories",
			Handler:    _CategoryService_GetCategories_Handler,
		},
		{
			MethodName: "DeleteCategory",
			Handler:    _CategoryService_DeleteCategory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cropconnect.proto",
}

// CommodityServiceClient is the client API for CommodityService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommodityServiceClient interface {
	CreateCommodity(ctx context.Context, in *Commodity, opts ...grpc.CallOption) (*CommodityResponse, error)
	GetCommodities(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CommodityList, error)
	GetCommodityByID(ctx context.Context, in *CommodityRequest, opts ...grpc.CallOption) (*CommodityResponse, error)
	UpdateCommodity(ctx context.Context, in *UpdateCommodityReq, opts ...grpc.CallOption) (*CommodityResponse, error)
	DeleteCommodity(ctx context.Context, in *CommodityRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
}

type commodityServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCommodityServiceClient(cc grpc.ClientConnInterface) CommodityServiceClient {
	return &commodityServiceClient{cc}
}

func (c *commodityServiceClient) CreateCommodity(ctx context.Context, in *Commodity, opts ...grpc.CallOption) (*CommodityResponse, error) {
	out := new(CommodityResponse)
	err := c.cc.Invoke(ctx, "/cropconnect.CommodityService/CreateCommodity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commodityServiceClient) GetCommodities(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CommodityList, error) {
	out := new(CommodityList)
	err := c.cc.Invoke(ctx, "/cropconnect.CommodityService/GetCommodities", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commodityServiceClient) GetCommodityByID(ctx context.Context, in *CommodityRequest, opts ...grpc.CallOption) (*CommodityResponse, error) {
	out := new(CommodityResponse)
	err := c.cc.Invoke(ctx, "/cropconnect.CommodityService/GetCommodityByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commodityServiceClient) UpdateCommodity(ctx context.Context, in *UpdateCommodityReq, opts ...grpc.CallOption) (*CommodityResponse, error) {
	out := new(CommodityResponse)
	err := c.cc.Invoke(ctx, "/cropconnect.CommodityService/UpdateCommodity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commodityServiceClient) DeleteCommodity(ctx context.Context, in *CommodityRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, "/cropconnect.CommodityService/DeleteCommodity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommodityServiceServer is the server API for CommodityService service.
// All implementations must embed UnimplementedCommodityServiceServer
// for forward compatibility
type CommodityServiceServer interface {
	CreateCommodity(context.Context, *Commodity) (*CommodityResponse, error)
	GetCommodities(context.Context, *Empty) (*CommodityList, error)
	GetCommodityByID(context.Context, *CommodityRequest) (*CommodityResponse, error)
	UpdateCommodity(context.Context, *UpdateCommodityReq) (*CommodityResponse, error)
	DeleteCommodity(context.Context, *CommodityRequest) (*DeleteResponse, error)
	mustEmbedUnimplementedCommodityServiceServer()
}

// UnimplementedCommodityServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCommodityServiceServer struct {
}

func (UnimplementedCommodityServiceServer) CreateCommodity(context.Context, *Commodity) (*CommodityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCommodity not implemented")
}
func (UnimplementedCommodityServiceServer) GetCommodities(context.Context, *Empty) (*CommodityList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCommodities not implemented")
}
func (UnimplementedCommodityServiceServer) GetCommodityByID(context.Context, *CommodityRequest) (*CommodityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCommodityByID not implemented")
}
func (UnimplementedCommodityServiceServer) UpdateCommodity(context.Context, *UpdateCommodityReq) (*CommodityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCommodity not implemented")
}
func (UnimplementedCommodityServiceServer) DeleteCommodity(context.Context, *CommodityRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCommodity not implemented")
}
func (UnimplementedCommodityServiceServer) mustEmbedUnimplementedCommodityServiceServer() {}

// UnsafeCommodityServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommodityServiceServer will
// result in compilation errors.
type UnsafeCommodityServiceServer interface {
	mustEmbedUnimplementedCommodityServiceServer()
}

func RegisterCommodityServiceServer(s grpc.ServiceRegistrar, srv CommodityServiceServer) {
	s.RegisterService(&CommodityService_ServiceDesc, srv)
}

func _CommodityService_CreateCommodity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Commodity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommodityServiceServer).CreateCommodity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.CommodityService/CreateCommodity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommodityServiceServer).CreateCommodity(ctx, req.(*Commodity))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommodityService_GetCommodities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommodityServiceServer).GetCommodities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.CommodityService/GetCommodities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommodityServiceServer).GetCommodities(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommodityService_GetCommodityByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommodityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommodityServiceServer).GetCommodityByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.CommodityService/GetCommodityByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommodityServiceServer).GetCommodityByID(ctx, req.(*CommodityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommodityService_UpdateCommodity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCommodityReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommodityServiceServer).UpdateCommodity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.CommodityService/UpdateCommodity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommodityServiceServer).UpdateCommodity(ctx, req.(*UpdateCommodityReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommodityService_DeleteCommodity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommodityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommodityServiceServer).DeleteCommodity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.CommodityService/DeleteCommodity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommodityServiceServer).DeleteCommodity(ctx, req.(*CommodityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CommodityService_ServiceDesc is the grpc.ServiceDesc for CommodityService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CommodityService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cropconnect.CommodityService",
	HandlerType: (*CommodityServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCommodity",
			Handler:    _CommodityService_CreateCommodity_Handler,
		},
		{
			MethodName: "GetCommodities",
			Handler:    _CommodityService_GetCommodities_Handler,
		},
		{
			MethodName: "GetCommodityByID",
			Handler:    _CommodityService_GetCommodityByID_Handler,
		},
		{
			MethodName: "UpdateCommodity",
			Handler:    _CommodityService_UpdateCommodity_Handler,
		},
		{
			MethodName: "DeleteCommodity",
			Handler:    _CommodityService_DeleteCommodity_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cropconnect.proto",
}

// BidServiceClient is the client API for BidService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BidServiceClient interface {
	CreateBid(ctx context.Context, in *Bid, opts ...grpc.CallOption) (*BidResponse, error)
	UpdateBid(ctx context.Context, in *Bid, opts ...grpc.CallOption) (*BidResponse, error)
	GetBidByCommodityId(ctx context.Context, in *BidRequest, opts ...grpc.CallOption) (*BidList, error)
	DeleteBid(ctx context.Context, in *BidRequest, opts ...grpc.CallOption) (*BidResponse, error)
	BidAccept(ctx context.Context, in *BidRequest, opts ...grpc.CallOption) (*BidResponse, error)
}

type bidServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBidServiceClient(cc grpc.ClientConnInterface) BidServiceClient {
	return &bidServiceClient{cc}
}

func (c *bidServiceClient) CreateBid(ctx context.Context, in *Bid, opts ...grpc.CallOption) (*BidResponse, error) {
	out := new(BidResponse)
	err := c.cc.Invoke(ctx, "/cropconnect.BidService/CreateBid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bidServiceClient) UpdateBid(ctx context.Context, in *Bid, opts ...grpc.CallOption) (*BidResponse, error) {
	out := new(BidResponse)
	err := c.cc.Invoke(ctx, "/cropconnect.BidService/UpdateBid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bidServiceClient) GetBidByCommodityId(ctx context.Context, in *BidRequest, opts ...grpc.CallOption) (*BidList, error) {
	out := new(BidList)
	err := c.cc.Invoke(ctx, "/cropconnect.BidService/GetBidByCommodityId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bidServiceClient) DeleteBid(ctx context.Context, in *BidRequest, opts ...grpc.CallOption) (*BidResponse, error) {
	out := new(BidResponse)
	err := c.cc.Invoke(ctx, "/cropconnect.BidService/DeleteBid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bidServiceClient) BidAccept(ctx context.Context, in *BidRequest, opts ...grpc.CallOption) (*BidResponse, error) {
	out := new(BidResponse)
	err := c.cc.Invoke(ctx, "/cropconnect.BidService/BidAccept", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BidServiceServer is the server API for BidService service.
// All implementations must embed UnimplementedBidServiceServer
// for forward compatibility
type BidServiceServer interface {
	CreateBid(context.Context, *Bid) (*BidResponse, error)
	UpdateBid(context.Context, *Bid) (*BidResponse, error)
	GetBidByCommodityId(context.Context, *BidRequest) (*BidList, error)
	DeleteBid(context.Context, *BidRequest) (*BidResponse, error)
	BidAccept(context.Context, *BidRequest) (*BidResponse, error)
	mustEmbedUnimplementedBidServiceServer()
}

// UnimplementedBidServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBidServiceServer struct {
}

func (UnimplementedBidServiceServer) CreateBid(context.Context, *Bid) (*BidResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBid not implemented")
}
func (UnimplementedBidServiceServer) UpdateBid(context.Context, *Bid) (*BidResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBid not implemented")
}
func (UnimplementedBidServiceServer) GetBidByCommodityId(context.Context, *BidRequest) (*BidList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBidByCommodityId not implemented")
}
func (UnimplementedBidServiceServer) DeleteBid(context.Context, *BidRequest) (*BidResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBid not implemented")
}
func (UnimplementedBidServiceServer) BidAccept(context.Context, *BidRequest) (*BidResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BidAccept not implemented")
}
func (UnimplementedBidServiceServer) mustEmbedUnimplementedBidServiceServer() {}

// UnsafeBidServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BidServiceServer will
// result in compilation errors.
type UnsafeBidServiceServer interface {
	mustEmbedUnimplementedBidServiceServer()
}

func RegisterBidServiceServer(s grpc.ServiceRegistrar, srv BidServiceServer) {
	s.RegisterService(&BidService_ServiceDesc, srv)
}

func _BidService_CreateBid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Bid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BidServiceServer).CreateBid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.BidService/CreateBid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BidServiceServer).CreateBid(ctx, req.(*Bid))
	}
	return interceptor(ctx, in, info, handler)
}

func _BidService_UpdateBid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Bid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BidServiceServer).UpdateBid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.BidService/UpdateBid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BidServiceServer).UpdateBid(ctx, req.(*Bid))
	}
	return interceptor(ctx, in, info, handler)
}

func _BidService_GetBidByCommodityId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BidServiceServer).GetBidByCommodityId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.BidService/GetBidByCommodityId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BidServiceServer).GetBidByCommodityId(ctx, req.(*BidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BidService_DeleteBid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BidServiceServer).DeleteBid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.BidService/DeleteBid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BidServiceServer).DeleteBid(ctx, req.(*BidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BidService_BidAccept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BidServiceServer).BidAccept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cropconnect.BidService/BidAccept",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BidServiceServer).BidAccept(ctx, req.(*BidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BidService_ServiceDesc is the grpc.ServiceDesc for BidService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BidService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cropconnect.BidService",
	HandlerType: (*BidServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateBid",
			Handler:    _BidService_CreateBid_Handler,
		},
		{
			MethodName: "UpdateBid",
			Handler:    _BidService_UpdateBid_Handler,
		},
		{
			MethodName: "GetBidByCommodityId",
			Handler:    _BidService_GetBidByCommodityId_Handler,
		},
		{
			MethodName: "DeleteBid",
			Handler:    _BidService_DeleteBid_Handler,
		},
		{
			MethodName: "BidAccept",
			Handler:    _BidService_BidAccept_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cropconnect.proto",
}
